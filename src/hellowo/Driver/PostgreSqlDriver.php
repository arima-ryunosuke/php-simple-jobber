<?php

namespace ryunosuke\hellowo\Driver;

use ErrorException;
use Exception;
use Generator;
use RuntimeException;
use ryunosuke\hellowo\Message;
use Throwable;

/**
 * architecture:
 * FOR UPDATE during job running.
 * SKIP LOCKED provides exclusive control of running jobs.
 * NOTIFY can be sent to waiting processes for immediate execution.
 */
class PostgreSqlDriver extends AbstractDriver
{
    public static function isEnabled(): bool
    {
        return extension_loaded('pgsql');
    }

    protected static function normalizeParams(array $params): array
    {
        $parts = explode('.', trim($params['path'] ?? '', '/'), 2);
        return [
            'database' => $parts[0] ?? null,
            'table'    => $parts[1] ?? null,
        ];
    }

    private        $connection;
    private string $table;

    private ?float  $starttime;
    private float   $waittime;
    private string  $waitmode;
    private ?string $sharedFile;

    private int   $heartbeat;
    private float $heartbeatTimer;

    private array $statements = [];

    public function __construct(array $options)
    {
        $options = self::normalizeOptions($options, [
            // pgsql instance or pgsql DSN
            'transport'  => [
                'host'     => '127.0.0.1',
                'port'     => 3306,
                'username' => null,
                'password' => null,
            ],
            // db and table
            'database'   => null,
            'table'      => 'hellowo',
            // null: wait waittime simply, int: wait until starttime+waittime
            'starttime'  => null,
            // one cycle wait time
            'waittime'   => 10.0,
            // sql: use SELECT SLEEP(), php: call usleep
            'waitmode'   => 'sql',
            // sharing job filename
            'sharedFile' => null,
            // kills sleeping connections of different hosts for sudden death. requires PROCESS privileges
            'heartbeat'  => 0,
        ]);

        // connection
        $transport = $options['transport'];
        if (is_array($transport)) {
            $transport = array_filter([
                'host'     => $transport['host'] ?? null,
                'port'     => $transport['port'] ?? null,
                'user'     => $transport['user'] ?? $transport['username'] ?? null,
                'password' => $transport['password'] ?? null,
                'dbname'   => $options['dbname'] ?? $options['database'] ?? null,
                //'application_name' => 'hellowo',
            ], fn($value) => $value !== '' && $value !== null);

            $DSN = implode(' ', array_map(
                fn($value, string $key) => sprintf("%s='%s'", $key, addslashes($value)),
                array_values($transport),
                array_keys($transport),
            ));

            $transport = pg_connect($DSN, PGSQL_CONNECT_FORCE_NEW);
        }
        $this->connection = $transport;
        $this->table      = $options['table'];

        $this->starttime  = $options['starttime'];
        $this->waittime   = $options['waittime'];
        $this->waitmode   = $options['waitmode'];
        $this->sharedFile = $options['sharedFile'];

        $this->heartbeat      = $options['heartbeat'];
        $this->heartbeatTimer = microtime(true) + $this->heartbeat;

        $hostport = pg_host($this->connection) . ':' . pg_port($this->connection);
        parent::__construct("postgresql {$hostport}/{$options['table']}");
    }

    protected function setup(bool $forcibly = false): void
    {
        if ($forcibly) {
            $this->execute("DROP TABLE IF EXISTS {$this->table}");
        }

        // table
        $this->execute(<<<SQL
            CREATE TABLE IF NOT EXISTS {$this->table}(
                job_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                message   BYTEA NOT NULL,
                priority  SMALLINT NOT NULL DEFAULT 0,
                start_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                retry     INT NOT NULL DEFAULT 0
            )
            SQL
        );

        if ($this->waitmode === 'sql') {
            pg_query($this->connection, 'LISTEN hellowo_awake');
        }

        if ($this->sharedFile !== null) {
            @mkdir(dirname($this->sharedFile), 0755, true);
        }
    }

    protected function isStandby(): bool
    {
        try {
            // job_id is unsigned int
            $this->execute("DELETE FROM {$this->table} WHERE job_id = $1", [-1]);
            return false;
        }
        catch (Throwable $e) {
            set_error_handler(function ($severity, $message, $file, $line) {
                throw new ErrorException($message, 0, $severity, $file, $line);
            });
            try {
                if (in_array(pg_connection_status($this->connection), [false, PGSQL_CONNECTION_BAD], true)) {
                    throw $e; // @codeCoverageIgnore
                }
            }
            finally {
                restore_error_handler();
            }

            return true;
        }
    }

    protected function select(): Generator
    {
        $jobs = $this->shareJob($this->sharedFile, $this->waittime, fn() => array_column($this->execute("SELECT job_id, priority FROM {$this->table} WHERE start_at <= NOW() ORDER BY priority DESC LIMIT 256 FOR UPDATE SKIP LOCKED"), null, 'job_id'));

        foreach ($jobs as $job_id => $job) {
            $this->execute('BEGIN');
            try {
                $job = $this->execute("SELECT * FROM {$this->table} WHERE job_id = $1 FOR UPDATE SKIP LOCKED", [$job_id])[0] ?? null;

                if ($job === null) {
                    $this->unshareJob($this->sharedFile, $job_id);
                    $this->execute('ROLLBACK');
                    continue;
                }

                $job['retry'] ??= 0; // for compatible
                $retry        = yield new Message($job['job_id'], pg_unescape_bytea($job['message']), $job['retry']);
                if ($retry === null) {
                    $this->execute("DELETE FROM {$this->table} WHERE job_id = $1", [$job['job_id']]);
                }
                else {
                    $this->execute("UPDATE {$this->table} SET start_at = NOW() + $1, retry = $2 WHERE job_id = $3", ["$retry SECOND", $job['retry'] + 1, $job['job_id']]);
                }
                $this->unshareJob($this->sharedFile, $job_id);
                $this->execute('COMMIT');
                return;
            }
            catch (Throwable $ex) {
                $this->execute('ROLLBACK');
                throw $ex;
            }
        }

        $this->sleep();
        $this->recover();
    }

    protected function error(Exception $e): bool
    {
        return !$this->execute('SELECT 1');
    }

    protected function close(): void
    {
        @pg_close($this->connection);
        unset($this->connection);

        gc_collect_cycles();
    }

    protected function send(string $contents, ?int $priority = null, ?float $delay = null): ?string
    {
        $priority = $priority ?? 32767;
        $delay    = $delay ?? 0;
        $id       = $this->execute(
            "INSERT INTO {$this->table}(message, priority, start_at) VALUES ($1, $2, NOW() + $3) RETURNING job_id",
            [/* pg_escape_bytea is not necessary when binding */ $contents, $priority, "$delay SECOND"],
        )[0]['job_id'];

        if (!$delay && $this->waitmode === 'sql') {
            $this->notify();
        }

        return $id;
    }

    protected function notify(int $count = 1): int
    {
        if ($this->waitmode === 'sql') {
            return $this->execute("NOTIFY hellowo_awake");
        }
        elseif ($this->waitmode === 'php') {
            return count(parent::notifyLocal($count));
        }
    }

    protected function clear(): int
    {
        return $this->execute("DELETE FROM {$this->table}");
    }

    protected function sleep(): void
    {
        if ($this->waitmode === 'sql') {
            $socket = pg_socket($this->connection);
            while (true) {
                $read  = [$socket];
                $write = $except = null;
                if (!@stream_select($read, $write, $except, 0, $this->waittime * 1000 * 1000)) {
                    break;
                }
                $notify = pg_get_notify($this->connection);
                if ($notify === false || $notify['message'] === 'hellowo_awake') {
                    break;
                }
            }
            fclose($socket);
        }
        elseif ($this->waitmode === 'php') {
            usleep(intval($this->waitTime($this->starttime, $this->waittime) * 1000 * 1000));
        }
    }

    protected function recover(): array
    {
        if (!$this->heartbeat) {
            return [];
        }

        if (microtime(true) < $this->heartbeatTimer) {
            return [];
        }
        $this->heartbeatTimer = microtime(true) + $this->heartbeat;

        $result = [];
        foreach ($this->processlist() as $process) {
            if ((time() - strtotime($process['state_change'])) >= $this->heartbeat) {
                if ($this->ping($process['client_addr'], 10) === false) {
                    $this->execute("SELECT pg_terminate_backend($1)", [$process['pid']]);
                    $result[$process['pid']] = $process;
                }
            }
        }
        return $result;
    }

    protected function processlist(): array
    {
        return $this->execute(
            "SELECT * FROM pg_stat_activity WHERE datname = CURRENT_DATABASE() AND pid <> pg_backend_pid() AND usename = CURRENT_USER",
        );
    }

    protected function execute(string $query, array $bind = [])
    {
        $stmtname  = sha1($query);
        $statement = $this->statements[$query] ??= pg_prepare($this->connection, $stmtname, $query);
        if ($statement === false) {
            throw new RuntimeException(pg_last_error($this->connection));
        }

        $result = pg_execute($this->connection, $stmtname, $bind);
        if ($result === false) {
            throw new RuntimeException(pg_last_error($this->connection));
        }
        try {
            if (pg_num_fields($result)) {
                return pg_fetch_all($result, PGSQL_ASSOC) ?: []; // under php8.1 empty set returns false
            }
            return pg_affected_rows($result);
        }
        finally {
            pg_free_result($result);
        }
    }
}
